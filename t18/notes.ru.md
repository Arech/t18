# Важные особенности, про которые важно помнить

## Про базовые типы данных

### Дата-время

Арифметика на mxTime/mxDate/mxTimestamp (где она есть) крайне ущербная и её можно использовать только наперёд зная, что результат не выйдет за границы разрешённых значений! См. код операторов арифметики.


## Про колбаки

### Тикеры

В тикер должны приходить абсолютно все маркет-данные по тикеру без какой-либо фильтрации, поскольку на основании колбаков тикера выполняется ведение трейдов.

Колбаки тикера ВСЕГДА вызываются ДО даже обновления данных в таймфреймах, а не только работы колбаков таймфреймов. Даже ДО обновления `lastKnownQuote`!! Поэтому хотя вешать колбаки на тикеры можно (не ранее конструктора объекта ТС, - но не в сетапе!), - надо чётко понимать, нахрена они нужны и почему этого нельзя сделать в колбаке таймфрейма.

В сетапе ТС вешать колбаки на тикер НЕЛЬЗЯ, поскольку они будут работать даже ДО колбаков, обрабатывающих ведение трейдов.

### Общая схема колбаков

Каждое колбачное событие (открытие бара, закрытие бара, наступление момента времени) и в тикере и в таймфреймах обрабатывают до 3х спец.функций: `*_pre` , основная и `*_post` так, чтобы сначала на всех уровнях (от тикера и до самого дальнего ТФ) отработала одна из этих функций, потом другая и только потом - третья.

`*_pre` функция есть только у обработчика события `newBarOpen` и она нужна, чтобы по поступлении данных, принадлежащих новому периоду, сначала бы каждый ТФ имел бы возможность закрыть бары, принадлежащие предыдущим периодам. Причём `_newBarOpen_pre()` передаётся каждому ТФ для проверки необходимости закрытия ранее открытых баров независимо от того, когда и как прошло закрытие баров нижележащих таймфреймов - чтобы исключить ситуацию, например, когда на М5 отработало закрытие бара в 1005, после чего тухлый рынок нарисовал следующую сделку только в 1011 - если М10 не получит событие `_newBarOpen_pre()` по времени 1011, то бар, открытый от 1000 останется незакрытым.

Основная функция собственно выполняет работу по обновлению данных, представляющих текущий бар.

Соответственно, только после того, как каждый ТФ обновил свои данные, вызывается `*_post`, которая уже бродкастит своё событие всем внешним подписчиками таймфрейма. Они могут работать с любыми таймфреймами и данные в этих ТФ будут когерентны друг другу.

### onBarClose

Колбак `onBarClose` ВСЕГДА происходит с запозданием относительно реального момента завершения бара по времени. Обычно это связано с приходом новых данных, принадлежащих новому периоду. Более того, по таймингу закрывать бар нельзя, - вдруг из-за сетевых задержек часть данных из периода ещё просто не передалась? Поэтому закрывать бар можно только по реальному получению данных, принадлежащих новому ТФ.

Поэтому торговать по цене закрытия бара ВСЕГДА физически невозможно - просто потому, что бар уже закрылся; нельзя торговать в закрытом баре. Попытки торговать по цене закрытия могут вызывать ассерты в дебуге, но могут проходить незамеченными в релизе.

### notifyDateTime

С `_notifyDateTime()` есть отдельный очень важный **ахтунг**!

Изначально функция предназначена для того, чтобы не просто уведомлять все компоненты о текущем времени, а чтобы заинтересованные таймфреймы могли бы определять моменты закрытия своих баров, если прошло уж слишком много времени после последней сделки, либо в случаях, когда, например, торговля просто заканчивается. Тут, однако, заложена мина, связанная с сетевыми задержками, - если мы закроем бар, а позже придёт потерявшийся пакет с данными, принадлежащими уже ранее закрытому бару, будет жопа и вообще GPF (шютка) (почти). Поэтому любой внешний код должен вызывать `notifyDateTime()` крайне осторожно и осознанно, чтобы не спровоцировать преждевременного закрытия баров.